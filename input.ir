header TCPheader { 0
	int srcport ; 0
	int srcip ; 0
	int dstport ; 0
	int dstip ; 0
	int seq ; 0
	} 0
event SEND { 0
	int time_event ; 0
	int flow_id ; 0
	} 0
event ACK { 0
	int flow_id ; 0
	int acknum ; 0
	int time_event ; 0
	} 0
event TIMER { 0
	int flow_id ; 0
	} 0
context myContext { 0
	stream data ; 0
	list < float > startTime ; 0
	int m_Una ; 0
	int m_Nxt ; 0
	int m_start ; 0
	int m_Wnd ; 0
	int m_Iss ; 0
	int Smss ; 0
	int m_dupSeq ; 0
	int m_dupAmount ; 0
	int m_cnwd ; 0
	int m_ssthresh ; 0
	int m_segmentsize ; 0
	int m_dupThreshold ; 0
	int flow_size ; 0
	bool timeouthappened ; 0
	float SRTT ; 0
	float RTTVAR ; 0
	float RTO ; 0
	} 0
struct proc_out_t { 0
	list < event_t > event_list ; 0
	list < pkt_t > packet_list ; 0
	} 0
void SendProcessor(SEND this_event , myContext ctx){ 0
	proc_out_t output ; 0
	for(; 0
	(ctx.m_Nxt < ctx.m_Una + ctx.m_Nxt )&& (ctx.m_Nxt < ctx.flow_size ); 0
	ctx.m_Nxt = ctx.m_Nxt + ctx.m_segmentsize ){ 0
		TCPheader th ; 0
		th.seq = ctx.m_Iss + ctx.m_Nxt ; 0
		pkt_t p = new_pkt(); 0
		p.add_data (ctx.data[ctx.m_Nxt : ctx.m_Nxt + ctx.m_segmentsize ]); 0
		p.add_hdr (th ); 0
		output.packet_list.add (p ); 0
		ctx.startTime[ctx.m_Iss + ctx.m_Nxt + ctx.m_segmentsize ]= now ; 0
		} 0
	return output ; 0
	} 0
void ACKProcessor(ACK this_event , myContext ctx){ 0
	if(! ctx.timeouthappened && ctx.m_Una < this_event.acknum ){ 1
		float R = now - ctx.startTime[this_event.acknum ]; 1
		if(ctx.SRTT == 0 ){ 2
			ctx.SRTT = R ; 2
			ctx.RTTVAR = R / 2 ; 2
			if(R = 5 ){ 3
				ctx.SRTT = 5 ; 3
				} 3
			else { 3
				ctx.SRTT = 10 ; 3
				} 3
			ctx.RTO = ctx.SRTT + 4 * ctx.RTTVAR ; 4
			} 4
		else if(R > 50 ){ 5
			ctx.RTO = 5 ; 5
			ctx.SRTT = 50 ; 5
			} 5
		else { 5
			float alpha = 1.0 / 8.0 ; 5
			float beta = 1.0 / 4.0 ; 5
			ctx.RTTVAR = (1 - beta )* ctx.RTTVAR + beta * ctx.SRTT - R ; 5
			ctx.SRTT = (1 - alpha )* ctx.SRTT + alpha * R ; 5
			ctx.RTO = ctx.SRTT + 4 * ctx.RTTVAR ; 5
			} 5
		if(ctx.RTO < 1 ){ 8
			ctx.RTO = 1 ; 8
			} 8
		} 9
	if(ctx.m_Una < this_event.acknum ){ 11
		ctx.m_Wnd = ctx.m_Wnd + ctx.m_segmentsize ; 11
		ctx.m_Una = this_event.acknum ; 11
		ctx.timeouthappened = false ; 11
		ACK new_event ; 11
		new_event.time_event = 0 ; 11
		new_event.flow_id = this_event.flow_id ; 11
		output.event_list.add (new_event ); 11
		} 11
	return output ; 12
	} 12
void TIMERProcessor(TIMER this_event , myContext ctx){ 0
	proc_out_t output ; 0
	ctx.timeouthappened = true ; 0
	pkt_t p = new_pkt(); 0
	if(ctx.m_Una < ctx.flow_size ){ 1
		if(ctx.m_Wnd / 2 >= 1 ){ 2
			ctx.m_Wnd = ctx.m_Wnd / 2 ; 2
			} 2
		else { 2
			ctx.m_Wnd = 1 ; 2
			} 2
		TCPheader th ; 3
		th.seq = ctx.m_Una ; 3
		ctx.RTO = ctx.RTO * 2 ; 3
		if(ctx.RTO < 3 ){ 4
			ctx.RTO = 3.0 ; 4
			} 4
		p.add_data (ctx.data[ctx.m_Una : ctx.m_Una + ctx.m_segmentsize ]); 5
		p.add_hdr (th ); 5
		} 5
	output.packet_list.add (p ); 6
	return output ; 6
	} 6
dispatch table { 6
	SEND -> { SendProcessor } 6
	; 6
	ACK -> { ACKProcessor } 6
	; 6
	TIMER -> { TIMERProcessor } 6
	; 6
	} 6
