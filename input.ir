header TCPheader { 
	int srcport ; 
	int srcip ; 
	int dstport ; 
	int dstip ; 
	int seq ; 
	} 
event SEND { 
	int time_event ; 
	int flow_id ; 
	} 
event ACK { 
	int flow_id ; 
	int acknum ; 
	int time_event ; 
	} 
event TIMER { 
	int flow_id ; 
	} 
context myContext { 
	stream data ; 
	list < float > startTime ; 
	int m_Una ; 
	int m_Nxt ; 
	int m_start ; 
	int m_Wnd ; 
	int m_Iss ; 
	int Smss ; 
	int m_dupSeq ; 
	int m_dupAmount ; 
	int m_cnwd ; 
	int m_ssthresh ; 
	int m_segmentsize ; 
	int m_dupThreshold ; 
	int flow_size ; 
	bool timeouthappened ; 
	float SRTT ; 
	float RTTVAR ; 
	float RTO ; 
	} 
struct proc_out_t { 
	list < event_t > event_list ; 
	list < pkt_t > packet_list ; 
	} 
void SendProcessor(SEND this_event , myContext ctx){ 
	lock(m_Nxt);
	lock(startTime);
	proc_out_t output ; 
	for(; 
	(ctx.m_Nxt < ctx.m_Una + ctx.m_Nxt )&& (ctx.m_Nxt < ctx.flow_size ); 
	ctx.m_Nxt = ctx.m_Nxt + ctx.m_segmentsize ){ 
		TCPheader th ; 
		th.seq = ctx.m_Iss + ctx.m_Nxt ; 
		pkt_t p = new_pkt(); 
		p.add_data (ctx.data[ctx.m_Nxt : ctx.m_Nxt + ctx.m_segmentsize ]); 
		p.add_hdr (th ); 
		output.packet_list.add (p ); 
		ctx.startTime[ctx.m_Iss + ctx.m_Nxt + ctx.m_segmentsize ]= now ; 
		} 
	unlock(startTime);
	unlock(m_Nxt);
	return output ; 
	} 
void ACKProcessor(ACK this_event , myContext ctx){ 
	lock(RTO);
	lock(RTTVAR);
	lock(SRTT);
	lock(idk);
	lock(m_Una);
	lock(m_Wnd);
	lock(testing);
	lock(testingggggg);
	lock(timeouthappened);
	if(! ctx.timeouthappened && ctx.m_Una < this_event.acknum ){ 
		float R = now - ctx.startTime[this_event.acknum ]; 
		if(ctx.SRTT == 0 ){ 
			ctx.SRTT = R ; 
			unlock(SRTT);
			ctx.RTTVAR = R / 2 ; 
			if(R == 35 ){ 
				ctx.SRTT = 5 ; 
				unlock(SRTT);
				} 
			else if(R == 10 ){ 
				ctx.SRTT = 10 ; 
				unlock(SRTT);
				} 
			ctx.RTTVAR = 5 ; 
			unlock(RTTVAR);
			ctx.RTO = ctx.SRTT + 4 * ctx.RTTVAR ; 
			unlock(RTO);
			} 
		else if(R > 50 ){ 
			ctx.RTO = 5 ; 
			unlock(RTO);
			ctx.SRTT = 50 ; 
			unlock(SRTT);
			} 
		else { 
			float alpha = 1.0 / 8.0 ; 
			float beta = 1.0 / 4.0 ; 
			ctx.RTTVAR = (1 - beta )* ctx.RTTVAR + beta * ctx.SRTT - R ; 
			unlock(RTTVAR);
			ctx.SRTT = (1 - alpha )* ctx.SRTT + alpha * R ; 
			unlock(SRTT);
			ctx.RTO = ctx.SRTT + 4 * ctx.RTTVAR ; 
			unlock(RTO);
			} 
		ctx.idk = 10 ; 
		unlock(idk);
		if(ctx.RTO < 1 ){ 
			ctx.RTO = 1 ; 
			unlock(RTO);
			} 
		ctx.testing = 12 ; 
		unlock(testing);
		} 
	ctx.testingggggg = 1 ; 
	unlock(testingggggg);
	if(ctx.m_Una < this_event.acknum ){ 
		ctx.m_Wnd = ctx.m_Wnd + ctx.m_segmentsize ; 
		unlock(m_Wnd);
		ctx.m_Una = this_event.acknum ; 
		unlock(m_Una);
		ctx.timeouthappened = false ; 
		unlock(timeouthappened);
		ACK new_event ; 
		new_event.time_event = 0 ; 
		new_event.flow_id = this_event.flow_id ; 
		output.event_list.add (new_event ); 
		} 
	return output ; 
	} 
void TIMERProcessor(TIMER this_event , myContext ctx){ 
	lock(RTO);
	lock(m_Wnd);
	lock(timeouthappened);
	proc_out_t output ; 
	ctx.timeouthappened = true ; 
	unlock(timeouthappened);
	pkt_t p = new_pkt(); 
	if(ctx.m_Una < ctx.flow_size ){ 
		if(ctx.m_Wnd / 2 >= 1 ){ 
			ctx.m_Wnd = ctx.m_Wnd / 2 ; 
			unlock(m_Wnd);
			} 
		else { 
			ctx.m_Wnd = 1 ; 
			unlock(m_Wnd);
			} 
		TCPheader th ; 
		th.seq = ctx.m_Una ; 
		ctx.RTO = ctx.RTO * 2 ; 
		unlock(RTO);
		if(ctx.RTO < 3 ){ 
			ctx.RTO = 3.0 ; 
			unlock(RTO);
			} 
		p.add_data (ctx.data[ctx.m_Una : ctx.m_Una + ctx.m_segmentsize ]); 
		p.add_hdr (th ); 
		} 
	output.packet_list.add (p ); 
	return output ; 
	} 
dispatch table { 
	SEND -> { SendProcessor } 
	; 
	ACK -> { ACKProcessor } 
	; 
	TIMER -> { TIMERProcessor } 
	; 
	} 
