header TCPheader { 0
	int srcport ; 0
	int srcip ; 0
	int dstport ; 0
	int dstip ; 0
	int seq ; 0
	} 0
event SEND { 0
	int time_event ; 0
	int flow_id ; 0
	} 0
event ACK { 0
	int flow_id ; 0
	int acknum ; 0
	int time_event ; 0
	} 0
event TIMER { 0
	int flow_id ; 0
	} 0
context myContext { 0
	stream data ; 0
	list < float > startTime ; 0
	int m_Una ; 0
	int m_Nxt ; 0
	int m_start ; 0
	int m_Wnd ; 0
	int m_Iss ; 0
	int Smss ; 0
	int m_dupSeq ; 0
	int m_dupAmount ; 0
	int m_cnwd ; 0
	int m_ssthresh ; 0
	int m_segmentsize ; 0
	int m_dupThreshold ; 0
	int flow_size ; 0
	bool timeouthappened ; 0
	float SRTT ; 0
	float RTTVAR ; 0
	float RTO ; 0
	} 0
struct proc_out_t { 0
	list < event_t > event_list ; 0
	list < pkt_t > packet_list ; 0
	} 0
void SendProcessor(SEND this_event , myContext ctx){ 0
	proc_out_t output ; 0
	for(; 0
	(ctx.m_Nxt < ctx.m_Una + ctx.m_Nxt )&& (ctx.m_Nxt < ctx.flow_size ); 0
	ctx.m_Nxt = ctx.m_Nxt + ctx.m_segmentsize ){ 0
		TCPheader th ; 0
		th.seq = ctx.m_Iss + ctx.m_Nxt ; 0
		pkt_t p = new_pkt(); 0
		p.add_data (ctx.data[ctx.m_Nxt : ctx.m_Nxt + ctx.m_segmentsize ]); 0
		p.add_hdr (th ); 0
		output.packet_list.add (p ); 0
		ctx.startTime[ctx.m_Iss + ctx.m_Nxt + ctx.m_segmentsize ]= now ; 0
		} 0
	return output ; 0
	} 0
void ACKProcessor(ACK this_event , myContext ctx){ 0
	if(! ctx.timeouthappened && ctx.m_Una < this_event.acknum ){ 1
		float R = now - ctx.startTime[this_event.acknum ]; 1
		if(ctx.SRTT == 0 ){ 2
			ctx.SRTT = R ; 2
			ctx.RTTVAR = R / 2 ; 2
			if(R == 35 ){ 3
				ctx.SRTT = 5 ; 3
				} 3
			else { 5
				ctx.SRTT = 10 ; 5
				} 5
			ctx.RTO = ctx.SRTT + 4 * ctx.RTTVAR ; 6
			} 6
		else if(R > 50 ){ 8
			ctx.RTO = 5 ; 8
			ctx.SRTT = 50 ; 8
			} 8
		else { 10
			float alpha = 1.0 / 8.0 ; 10
			float beta = 1.0 / 4.0 ; 10
			ctx.RTTVAR = (1 - beta )* ctx.RTTVAR + beta * ctx.SRTT - R ; 10
			ctx.SRTT = (1 - alpha )* ctx.SRTT + alpha * R ; 10
			ctx.RTO = ctx.SRTT + 4 * ctx.RTTVAR ; 10
			} 10
		ctx.sei_la = 10 ; 12
		if(ctx.RTO < 1 ){ 13
			ctx.RTO = 1 ; 13
			} 13
		ctx.testing = 12 ; 14
		} 14
	ctx.testandoooo = 1 ; 15
	if(ctx.m_Una < this_event.acknum ){ 16
		ctx.m_Wnd = ctx.m_Wnd + ctx.m_segmentsize ; 16
		ctx.m_Una = this_event.acknum ; 16
		ctx.timeouthappened = false ; 16
		ACK new_event ; 16
		new_event.time_event = 0 ; 16
		new_event.flow_id = this_event.flow_id ; 16
		output.event_list.add (new_event ); 16
		} 16
	return output ; 17
	} 17
void TIMERProcessor(TIMER this_event , myContext ctx){ 0
	proc_out_t output ; 0
	ctx.timeouthappened = true ; 0
	pkt_t p = new_pkt(); 0
	if(ctx.m_Una < ctx.flow_size ){ 1
		if(ctx.m_Wnd / 2 >= 1 ){ 2
			ctx.m_Wnd = ctx.m_Wnd / 2 ; 2
			} 2
		else { 4
			ctx.m_Wnd = 1 ; 4
			} 4
		TCPheader th ; 5
		th.seq = ctx.m_Una ; 5
		ctx.RTO = ctx.RTO * 2 ; 5
		if(ctx.RTO < 3 ){ 6
			ctx.RTO = 3.0 ; 6
			} 6
		p.add_data (ctx.data[ctx.m_Una : ctx.m_Una + ctx.m_segmentsize ]); 7
		p.add_hdr (th ); 7
		} 7
	output.packet_list.add (p ); 8
	return output ; 8
	} 8
dispatch table { 8
	SEND -> { SendProcessor } 8
	; 8
	ACK -> { ACKProcessor } 8
	; 8
	TIMER -> { TIMERProcessor } 8
	; 8
	} 8
